\قسمت{الگوهای طراحی}


در این قسمت به الگوهای طراحی \زیرنویس{\لر{Design Patterns}} استفاده شده در این پروژه می‌پردازیم.

\شروع{فقرات}

	\فقره \مهم{الگوی \لر{Iterator}}
%	
	\شروع{شکل}[htbp!]
		\centerimg{./dp/iterator.png}{.8\linewidth}
		\شرح{الگوی \لر{Iterator}}
		\برچسب{شکل:الگوی Iterator}
	\پایان{شکل}
	
	از این الگوی طراحی بسیار استفاده شده است. هر جا لیست داریم، یک  \لر{Iterator}ی \لر{built-in} که در زبان وجود دارد استفاده شده است. به صورت مثال در رابط کاربری در مواقعی که کوئری‌ را دریافت می‌کنیم، جوابش به صورت لیست است، کتاب‌خانه \لر{Apollo} یک \لر{iterator} دارد که از یک عضو لیست شروع می‌کند و به بعدی می‌رود تا از تمام اعضای لیست یک به یک بگذرد. کد آن به صورت زیر است.
	
%	
	\شروع{شکل}[htbp!]
	\centerimg{./dp/iterator-code.png}{.5\linewidth}
	\شرح{مثال الگوی \لر{Iterator}}
	\برچسب{شکل:مثال الگوی Iterator}
	\پایان{شکل}
	
%	\newpage
	
	\فقره \مهم{الگوی \لر{Singleton}}
	
کلاس \لر{VehicleCatalogue} به صورت \لر{Singleton} است. یعنی فقط یک نمونه از این کلاس موجود است. ساختار این نوع کلاس‌ها به شکل زیر است:

%
	\شروع{شکل}[htbp!]
	\centerimg{./dp/singleton.png}{.8\linewidth}
	\شرح{مثال الگوی \لر{Singleton}}
	\برچسب{شکل:مثال الگوی Singleton}
	\پایان{شکل}
	
%	\newpage
	\فقره \مهم{الگوی \لر{Adaptor}}
	
	ما با تکنولوژی \لر{graphql} برای ساختن \لر{API} کار می‌کنیم. به‌همین‌خاطر در رابط کاربری باید با استفاده از کتاب‌خانه \لر{Apollo} کوئری بزنیم. اما سمت \لر{back-end} همیشه در حال تغییر است، و با کمی تغییر کلا کوئری‌های ما به‌هم می‌خورد. راهکار موجود را شرح می دهیم.
	
		\شروع{شکل}[htbp!]
		\centerimg{./dp/adapter.png}{.8\linewidth}
		\شرح{مثال الگوی \لر{Adaptor}}
		\برچسب{شکل:مثال الگوی Adaptor}
		\پایان{شکل}
		
		کافی است یک کلاس ابسترکت کوئری داشته باشیم، این کلاس یک تابع ابسترکت \لر{createQuery} داشته باشد. سپس برای تولید کوئری تابع \لر{createQuery} در \لر{instance} مورد نظر از کلاس را صدا کنیم. مثلا برای زدن کوئری \لر{login} کافی است، تابع \لر{createQuery} در \لر{LoginQuery} صدا شود. حال اگر تغییری در کد ایجاد شد کافی است \لر{createQuery} رو برابر با کوئری در کلاسی کنیم که سمت بک تعریف شده است.

																												\فقره \مهم{الگوی \لر{Facade}}
به صورت 
\لر{built-in}
ساختار 
\لر{graphql}
و 
\لر{apollo}
از الگوی
\لر{Facade}
پیروی میکند، زیرا کلا ساختار به این شکل است که 
\لر{back-end}
به عنوان 
\لر{client}
ای برای 
\لر{front-end}
عمل میکند و ارتباط مستقیمی بین آن ها وجود ندارد. این وسط کتابخانه ی
\لر{graphene}
به عنوان فساد عمل می‌کند. برای به وجود آمدن هر تغییری در پایگاه داده در قسمت فرانت یک کوئری به کلاینت در کتابخانه 
\لر{graphene}
زده می‌شود. این کوئری را کتابخانه می‌گیرد، و به بک پاس می‌دهد تا بک اعمال لازم را بر آن انجام دهد و نتیجه آن را بر میگرداند. ساختار کلی الگوی 
\لر{Facade}
در شکل زیر آمده است.


	\شروع{شکل}[htbp!]
		\centerimg{./dp/Facade.png}{.8\linewidth}
		\شرح{الگوی \لر{Facade}}
		\برچسب{شکل:الگوی Facede}
	\پایان{شکل}


\فقره \مهم{الگوی \لر{Factory method}}
تمامی کلاس های کاتالوگ از یک نوعی از این الگو استفاده می‌کنند. به طور مثال کلاس
\لر{DriverCatalogue}
یک کلاس سینگلتون است که یک لیست از راننده ها دارد، و بر روی این لیست تعداد عملیات تعریف شده است. ساختار این الگو برای
\لر{DriverCatalogue}
در شکل زیر آمده است.

	\شروع{شکل}[htbp!]
		\centerimg{./dp/factory-method.png}{.8\linewidth}
		\شرح{الگوی \لر{Factory method}}
		\برچسب{شکل:الگوی factory}
	\پایان{شکل}

\فقره \مهم{الگوی \لر{state}}
در کلاس کلاینت چهار عدد 
\لر{clientState}
وجود دارد، که نشانه لاگین بودن هر یک از 4 نوع کاربر یعنی راننده، مشتری، ادمین،  و مدیر احراز هویت هستند.
حالا صفحه 
\لر{index}
برای هر کدام از 4 
\لر{state}
رو به رو صفحات متفاوتی را نمایش میدهد. در واقع برای هر کدام از 4 
\لر{state}
یکی از محتوایت 
\لر{driverRoot}
یا
\لر{customerRoot}
یا
\لر{authorizerRoot}
یا
\لر{adminRoot}
را نمایش می دهد. در واقع در ساختار این الگوی طراحی نمایش داده شده در شکل زیر، 
\لر{index}
در واقع نقش 
\لر{context} 
را بازی می‌کند.


	\شروع{شکل}[htbp!]
		\centerimg{./dp/state.png}{.8\linewidth}
		\شرح{الگوی \لر{state}}
		\برچسب{شکل:الگوی state}
	\پایان{شکل}





\پایان{فقرات}
